

## Why RPC

- Many client/server apps repeat the same boilerplate (connection setup, request/response flow); only the request details differ.![](https://assets.omscs.io/notes/3F721352-2899-4EBA-A6B0-6EADB5E2581E.png)
- Remote Procedure Call (RPC) emerged to streamline this common pattern.


## Benefits of RPC

- RPC abstracts cross-address-space/machine communication behind high-level calls so developers focus on application logic, not transport setup.
- It bundles common error handling for low-level transmission issues.
- It hides most of the complexity of talking across machines.


## RPC Requirements

- RPC targets client/server IPC with synchronous call semantics: caller blocks until the remote procedure returns, just like a local call.
- Strong type checking catches mismatched arguments and aids runtime byte-stream interpretation.
- The runtime normalizes data representation (e.g., network-order integers) to hide endianness or floating-point differences between machines.
- RPC is transport-agnostic (UDP, TCP, etc.) and layers in higher-level features such as authentication, access control, and fault tolerance.

## Structure of RPC

- RPC lets a client call add(i, j) even without the implementation; a generated client stub serializes the function name and arguments into a buffer and sends it over the transport.![](https://assets.omscs.io/notes/22426858-74EF-4124-98ED-80238E938AD4.png)
- The server stub deserializes the request, invokes the real add locally, packages the result, and sends it back.
- Stubs are auto-generated by the RPC toolkit; the client resumes once the reply arrives, seeing the return value as if it were a local call.

## Steps in RPC

- Step 0: the server registers its procedures, arguments, and contact info so clients can find it.
- Binding: client discovers the server and (for connection protocols) establishes the connection.![](https://assets.omscs.io/notes/8E8660BC-CC54-4A5B-8768-7BDF0796BA89.png)
- Call: client hands control to the stub, which marshals arguments into a contiguous buffer.
- Transport: RPC runtime sends the buffer over the agreed protocol.
- Receive: server runtime routes the request to the right stub, which unmarshals the buffer.
- Execute: stub invokes the real procedure; result is marshaled back and returned to the client, which resumes execution.


## Interface Design Language

- Clients and servers can be developed independently—even in different languages—but they must agree on the available procedures and argument types.
- Standardizing that agreement lets the RPC runtime auto-generate stubs.
- Interface Definition Languages (IDLs) capture this contract, describing the RPC interface for both sides.


## Specifying an IDL

- An IDL describes the RPC interface: procedure names, argument types, return type, plus a version number to distinguish revisions.
- IDLs can be language-agnostic (SunRPC’s XDR) or tied to a language (Java RMI).
- Language-specific IDLs are convenient for native developers; language-neutral ones suit mixed-language teams.
- The IDL only defines the contract—used for stub generation and service discovery—not the service implementation itself.


## Marshalling

- Marshaling turns separate arguments (e.g., i, j) into one contiguous payload.
- The stub encodes procedure metadata (add) plus arguments in a agreed byte layout so the server can deserialize it correctly.
- ![](https://assets.omscs.io/notes/938F6FC8-08F2-4280-B95B-75AFA74E3B4A.png)


## Unmarshalling

- Unmarshalling reads the incoming buffer, uses the procedure descriptor to parse out each argument’s bytes, and rebuilds server-side variables (e.g., i, j) with those values.![](https://assets.omscs.io/notes/CA66D7D2-E21F-484A-A0C5-B87185CE6515.png)
- RPC toolchains auto-generate the marshal/unmarshal code from the IDL; developers just link those stubs into their client/server programs.


## Binding and Registry

- Binding links a client to the correct server by matching service name/version and returning connection details (IP, port, protocol).
- A registry (yellow pages for services) stores this mapping; implementations range from global directories to per-machine daemons.
- Naming can be strict (exact name/version) or flexible (synonyms like sum → add).


## Pointers in RPC

- Raw pointers can’t cross processes—they reference meaningless addresses on the remote machine.
- Some RPC systems forbid pointer arguments outright; others copy the pointed-to data into the marshaled buffer instead.
- Upon unmarshalling, the server places the data locally and passes its address to the callee, so pointers appear to work.


## Handling Partial Failures

- RPC failures are hard to diagnose—timeouts could stem from server, service, network, or message loss, and retries don’t guarantee clarity.
- To cope, runtimes return a generic RPC error code that flags “something went wrong” without pinpointing the exact cause.


## What is SunRPC?

- SunRPC (1980s Sun UNIX) assumes the server host is known and uses a per-machine registry for service lookup.
- It’s language-agnostic, using XDR for both interface definitions and data encoding.
- Pointers are allowed; their referenced data gets serialized.
- The runtime supports configurable retries on timeout and strives to return meaningful error codes.


## SunRPC Overview

- Server interface is defined in an XDR .x file; SunRPC’s rpcgen compiler turns it into language-specific client/server stubs.
- On startup, the server registers with the local registry daemon, advertising service name, version, protocol, and port.
- Clients first query that per-machine registry to obtain contact details, then create an RPC handle to track their session state.
- ![](https://assets.omscs.io/notes/B8BC74B4-5D1E-498A-AD50-8F3F83984312.png)



## SunRPC XDR Example

- The XDR .x file defines the SQUARE_PROG service: input/output structs (square_in, square_out), the SQUARE_PROC procedure, its numeric IDs, version, and service ID.![](https://assets.omscs.io/notes/A4A18EDB-56E6-44B3-975A-E6408F565B64.png)
- Clients bind using service/procedure names and numbers; the RPC runtime relies on the numeric service ID, procedure ID, and version to route calls.![](https://assets.omscs.io/notes/A052ACC9-7F3E-4DA1-9359-AE681079494B.png)



## Compiling XDR

- Run rpcgen -C interface.x to auto-generate C support files:
    - interface.h with type definitions and prototypes
    - interface_svc.c server stub (includes main, registration, request parsing)
    - interface_clnt.c client stub wrapper
    - interface_xdr.c marshal/unmarshal routines shared by both sides

- Developer fills in the actual server procedure implementation and then calls the generated client wrapper like a normal function.

- ![](https://assets.omscs.io/notes/900EBDD1-DB17-45DD-A88F-05F540A29F47.png)


## Summarizing XDR Compilation

- Default rpcgen output isn’t thread-safe; use rpcgen -C -M interface.x to generate thread-safe stubs.
- -M just makes the generated code safe for multithreading—it doesn’t create a multithreaded server.
- Solaris supports -A for auto-generated multithreaded servers; on Linux you must implement threading yourself.
- ![](https://assets.omscs.io/notes/921D2058-0023-44E9-9B95-817573324DA8.png)


## SunRPC Registry

- SunRPC’s server registration code is generated automatically by rpcgen.
- Each machine runs a registry daemon called portmapper; start it on Linux with sudo /sbin/portmap.
- Servers register there, and clients query it to get service contact info.
- Use /usr/sbin/rpcinfo -p to list registered services (program ID, version, protocol, port, name).
- Portmapper itself listens on socket 111 for both TCP and UDP.


## SunRPC Binding

- Clients bind to a SunRPC service with clnt_create(host, program, version, protocol), e.g. clnt_create(rpc_host_name, SQUARE_PROG, SQUARE_VERS, "tcp").
- SQUARE_PROG and SQUARE_VERS are #defines generated from the .x file.
- The returned CLIENT* handle is reused for subsequent calls and carries status/error/auth info.


## XDR Data Types

- XDR-defined interfaces must use XDR-supported types (e.g., char, byte, int, float, const).
- hyper = 64-bit int; quadruple = 128-bit float; opaque = raw bytes (good for images).
- Arrays: fixed (int data[80]) or variable (int data<80>), where variable arrays compile to { int len; T *val; }. Sender fills len and val; receiver reads len then allocates/copies.
- Strings are transmitted as { len, data } but stored in memory as null-terminated.


## XDR Routines

- rpcgen writes all marshaling/unmarshaling code into interface_xdr.c.
- It also generates cleanup helpers like xdr_free; you implement user_defined_freeresult to release any allocated state.
- The RPC runtime invokes  user_defined_freeresult automatically once a request has been serviced.

## Encoding

- RPC messages carry metadata (service ID, procedure ID, version, request ID) in their headers so servers can route calls correctly and echo info in replies.
- Payloads (arguments/results) are serialized into a shared byte format—sometimes matching memory layout, sometimes not—as long as both sides can decode it.
- The RPC message is then wrapped in transport headers (TCP/UDP) before transmission.


## XDR Encoding

- XDR standardizes on-wire encoding: every data type occupies a multiple of four bytes (single-byte values get padded).
- All values transmit in big-endian order; integers use two’s complement and floats use IEEE format.
- ![](https://assets.omscs.io/notes/FF850174-AB55-4111-82DD-59CE3A9C98A7.png)

## Java RMI

- Java RMI (from Sun) brings RPC-style communication to JVMs, using method calls instead of procedures.
- The IDL is Java-specific since both stubs and implementations are pure Java.
- RMI runtime splits into a Remote Reference Layer (handles unicast/broadcast semantics and return policies) and a Transport Layer (implements protocols like TCP, UDP, shared memory).

## Overall Summary

- RPC makes cross-machine communication feel like regular function calls, hiding transport setup, type checks, and error handling so developers focus on core logic.
- Interfaces are captured in an IDL, enabling autogenerated stubs that marshal/unmarshal data, normalize byte order, and use registries for discovery and binding.
- The notes highlight challenges—pointers lack meaning across processes and partial failures are ambiguous—and show how SunRPC mitigates them with tools like rpcgen, portmapper, and XDR’s standardized encoding.
- Java RMI offers a JVM-centric flavor of RPC, layering remote references over transport protocols to keep distributed Java method calls looking local.